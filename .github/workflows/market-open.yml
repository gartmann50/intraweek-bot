name: IW Bot — Market Open

on:
  schedule:
    # Keep Mon–Fri so a Monday market holiday still buys on Tuesday
    - cron: "25 12 * * 1-5"   # pre-open window during EST
    - cron: "25 13 * * 1-5"   # pre-open window during EDT
  workflow_dispatch:
    inputs:
      force_buy:
        description: "Force weekly buy now (bypass first-session gate + dup guard)"
        type: boolean
        default: false

      topk:
        description: "Top-K momentum buys (default 6)"
        required: false
        default: "6"

      enable_momentum:
        description: "Enable MOMENTUM strategy"
        type: boolean
        default: true

      momentum_notional:
        description: "MOMENTUM notional per name (USD)"
        required: false
        default: "10000"

      enable_breakout:
        description: "Enable BREAKOUT strategy"
        type: boolean
        default: false

      breakout_notional:
        description: "BREAKOUT notional per name (USD)"
        required: false
        default: "5000"

concurrency:
  group: iwbot-open
  cancel-in-progress: false

jobs:
  open:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read

    env:
      # Top-K only meaningful for momentum
      TOPK: ${{ github.event.inputs.topk || '6' }}

      # Strategy toggles:
      # - On schedule: momentum ON, breakout OFF (safe)
      # - On manual: honor inputs
      ENABLE_MOMENTUM: ${{ github.event_name == 'schedule' && 'true' || (github.event.inputs.enable_momentum == 'true' && 'true' || 'false') }}
      ENABLE_BREAKOUT: ${{ github.event_name == 'schedule' && 'false' || (github.event.inputs.enable_breakout == 'true' && 'true' || 'false') }}

      # Notional sizing:
      # - On schedule: defaults (momentum 10k, breakout 5k)
      # - On manual: honor inputs
      MOMENTUM_NOTIONAL: ${{ github.event_name == 'schedule' && '10000' || (github.event.inputs.momentum_notional || '10000') }}
      BREAKOUT_NOTIONAL: ${{ github.event_name == 'schedule' && '5000'  || (github.event.inputs.breakout_notional || '5000') }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas numpy requests

      - name: Show config (toggles + sizing)
        run: |
          echo "ENABLE_MOMENTUM=${{ env.ENABLE_MOMENTUM }}"
          echo "ENABLE_BREAKOUT=${{ env.ENABLE_BREAKOUT }}"
          echo "MOMENTUM_NOTIONAL=${{ env.MOMENTUM_NOTIONAL }}"
          echo "BREAKOUT_NOTIONAL=${{ env.BREAKOUT_NOTIONAL }}"
          echo "TOPK=${{ env.TOPK }}"
          echo "force_buy=${{ github.event.inputs.force_buy }}"

      # --- Compute last Friday (NY) ---
      - name: When (NY)
        id: when
        shell: python
        run: |
          from datetime import datetime, timedelta
          from zoneinfo import ZoneInfo
          import os
          ny = ZoneInfo("America/New_York")
          d = datetime.now(ny).date()
          while d.weekday() != 4:
              d -= timedelta(days=1)
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"friday={d}\n")
          print("Anchor Friday:", d)

      # --- Duplicate-buy guard per week (keyed by Friday date) ---
      - name: Dup guard for this Friday
        id: opened
        uses: actions/cache@v4
        with:
          path: .open-flag
          key: opened-${{ steps.when.outputs.friday }}

      - name: Exit if already opened this week
        if: steps.opened.outputs.cache-hit == 'true' && github.event.inputs.force_buy != 'true'
        run: echo "Already opened for ${{ steps.when.outputs.friday }}; exiting." && exit 0

      # --- Download weekly picks artifact (latest successful Friday Build) ---
      - name: Download weekly picks artifact (latest)
        uses: dawidd6/action-download-artifact@v2
        with:
          repo: ${{ github.repository }}
          workflow: friday-build.yml
          branch: main
          workflow_conclusion: success
          search_artifacts: true
          name_is_regexp: true
          name: ^weekly-picks-.*$
          path: backtests
          if_no_artifact_found: fail

      # --- Normalize picklist path (artifact may be nested) ---
      - name: Normalize picklist path
        shell: bash
        run: |
          set -euo pipefail
          shopt -s globstar nullglob
          cand=(backtests/**/picklist_highrsi_trend.csv backtests/picklist_highrsi_trend.csv)
          for f in "${cand[@]}"; do
            if [[ -f "$f" ]]; then
              cp -f "$f" backtests/picklist_highrsi_trend.csv
              echo "Picklist copied from $f"
              exit 0
            fi
          done
          echo "ERROR: picklist_highrsi_trend.csv not found in downloaded artifacts"
          find backtests -maxdepth 3 -type f -print || true
          exit 1

      # --- Normalize breakout symbols (optional) ---
      - name: Normalize breakout symbols (optional)
        id: brk
        shell: bash
        run: |
          set -euo pipefail
          f="$(find backtests -maxdepth 3 -type f -name 'breakout_symbols.txt' -print -quit || true)"
          if [[ -n "$f" ]]; then
            cp -f "$f" backtests/breakout_symbols.txt
            echo "found=1" >> "$GITHUB_OUTPUT"
            echo "Breakout list found: $f"
            sed -n '1,15p' backtests/breakout_symbols.txt || true
          else
            echo "found=0" >> "$GITHUB_OUTPUT"
            echo "No breakout_symbols.txt found in weekly artifact."
          fi

      - name: Derive WEEK from picklist (export)
        shell: python
        run: |
          import os, pandas as pd
          p = "backtests/picklist_highrsi_trend.csv"
          df = pd.read_csv(p)
          wk = "week_start" if "week_start" in df.columns else ("week" if "week" in df.columns else None)
          if not wk:
              raise SystemExit("No week column (week_start/week) in picklist.")
          week = str(pd.to_datetime(df[wk], errors="coerce").dropna().dt.date.max())
          print("WEEK =", week)
          open(os.environ["GITHUB_ENV"], "a").write(f"WEEK={week}\n")

      - name: Sanity — show backtests/
        run: ls -Rlh backtests || true

      # --- Gate to US open (sleep ≤2h unless forced) ---
      - name: Gate to U.S. open (sleep ≤2h)
        id: gate
        env:
          ALPACA_KEY:    ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENV:    live
          FORCE_BUY:     ${{ github.event.inputs.force_buy }}
        shell: python
        run: |
          import os, time, sys, requests, datetime as dt
          if str(os.getenv("FORCE_BUY","false")).lower()=="true":
              open(os.environ["GITHUB_OUTPUT"],"a").write("go=1\n")
              print("FORCE_BUY=true → go=1")
              sys.exit(0)

          base = "https://paper-api.alpaca.markets" if os.getenv("ALPACA_ENV","paper").startswith("paper") else "https://api.alpaca.markets"
          H = {"APCA-API-KEY-ID": os.environ["ALPACA_KEY"], "APCA-API-SECRET-KEY": os.environ["ALPACA_SECRET"]}

          c = requests.get(f"{base}/v2/clock", headers=H, timeout=20).json()
          if c.get("is_open"):
              open(os.environ["GITHUB_OUTPUT"],"a").write("go=1\n")
              print("Market already open → go=1")
              sys.exit(0)

          t = dt.datetime.fromisoformat(c["next_open"].replace("Z","+00:00"))
          sec = max(0, (t - dt.datetime.now(dt.timezone.utc)).total_seconds())
          if sec > 7200:
              open(os.environ["GITHUB_OUTPUT"],"a").write("go=0\n")
              print("Next open is >2h away → go=0")
              sys.exit(0)

          print(f"Sleeping {int(sec)+3}s until open…")
          time.sleep(int(sec)+3)
          open(os.environ["GITHUB_OUTPUT"],"a").write("go=1\n")

      # --- Decide if first session after Friday (unless forced) ---
      - name: Decide if first session after Friday
        id: buygate
        if: ${{ steps.gate.outputs.go == '1' }}
        env:
          ALPACA_KEY:    ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENV:    live
          FORCE_BUY:     ${{ github.event.inputs.force_buy }}
        shell: python
        run: |
          import os, requests, datetime as dt
          from zoneinfo import ZoneInfo

          if str(os.getenv("FORCE_BUY","false")).lower()=="true":
              open(os.environ["GITHUB_OUTPUT"],"a").write("do=1\n")
              print("force_buy=true → buygate.do=1")
              raise SystemExit(0)

          base = "https://paper-api.alpaca.markets" if os.getenv("ALPACA_ENV","paper").startswith("paper") else "https://api.alpaca.markets"
          H = {"APCA-API-KEY-ID": os.environ["ALPACA_KEY"], "APCA-API-SECRET-KEY": os.environ["ALPACA_SECRET"]}

          friday = "${{ steps.when.outputs.friday }}"
          start  = (dt.date.fromisoformat(friday) + dt.timedelta(days=1)).isoformat()
          end    = (dt.date.fromisoformat(friday) + dt.timedelta(days=7)).isoformat()

          cal = requests.get(f"{base}/v2/calendar", params={"start": start, "end": end}, headers=H, timeout=20).json()
          first = (cal[0]["date"] if cal else None)

          today = dt.datetime.now(dt.timezone.utc).astimezone(ZoneInfo("America/New_York")).date().isoformat()
          do = "1" if first and today == first else "0"

          open(os.environ["GITHUB_OUTPUT"],"a").write(f"do={do}\n")
          print("first:", first, "today:", today, "BUY=", do)

      # ======================
      # MOMENTUM
      # ======================
      - name: Prepare MOMENTUM buy list (Top-K) — skip held / open buys
        id: momlist
        if: ${{ env.ENABLE_MOMENTUM == 'true' && steps.gate.outputs.go == '1' && steps.buygate.outputs.do == '1' }}
        env:
          ALPACA_KEY:    ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENV:    live
          TOPK:          ${{ env.TOPK }}
        shell: python
        run: |
          import os, requests, pandas as pd
          from pathlib import Path

          pick = Path("backtests/picklist_highrsi_trend.csv")
          df = pd.read_csv(pick)

          wkcol = "week_start" if "week_start" in df.columns else ("week" if "week" in df.columns else None)
          week = str(pd.to_datetime(df[wkcol], errors="coerce").dropna().dt.date.max())

          if "rank" in df.columns:
              df = df.sort_values(["rank","symbol"], ascending=[True,True])
          elif "score" in df.columns:
              df = df.sort_values(["score","symbol"], ascending=[False,True])

          topk = int(os.getenv("TOPK","6"))
          picks = (df[pd.to_datetime(df[wkcol], errors="coerce").dt.date.astype(str) == week]["symbol"]
                    .dropna().astype(str).head(topk).tolist())

          base = "https://paper-api.alpaca.markets" if os.getenv("ALPACA_ENV","paper").startswith("paper") else "https://api.alpaca.markets"
          H = {"APCA-API-KEY-ID": os.environ["ALPACA_KEY"], "APCA-API-SECRET-KEY": os.environ["ALPACA_SECRET"]}

          held=set()
          r=requests.get(f"{base}/v2/positions", headers=H, timeout=20)
          if r.status_code==200:
              for pos in (r.json() or []):
                  q=float(pos.get("qty") or 0)
                  if abs(q)>0:
                      held.add((pos.get("symbol") or "").upper())

          buying=set()
          r=requests.get(f"{base}/v2/orders", params={"status":"open","limit":500}, headers=H, timeout=20)
          if r.status_code==200:
              for od in (r.json() or []):
                  if od.get("side")=="buy" and od.get("symbol"):
                      buying.add(od["symbol"].upper())

          filtered=[s.upper() for s in picks if s.upper() not in held and s.upper() not in buying]
          Path("backtests").mkdir(exist_ok=True)
          Path("backtests/buy_symbols_momentum.txt").write_text("\n".join(filtered)+("\n" if filtered else ""), encoding="utf-8")

          any_buy="1" if filtered else "0"
          print("Momentum picks:", picks)
          print("Filtered momentum:", filtered)
          open(os.environ["GITHUB_OUTPUT"],"a").write(f"any={any_buy}\n")

      - name: Execute MOMENTUM buys (notional per name) + write lots
        id: mombuy
        if: ${{ env.ENABLE_MOMENTUM == 'true' && steps.gate.outputs.go == '1' && steps.buygate.outputs.do == '1' && steps.momlist.outputs.any == '1' }}
        env:
          ALPACA_KEY:    ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENV:    live
          NOTIONAL_PER:  ${{ env.MOMENTUM_NOTIONAL }}
          BUY_LIST_PATH: "backtests/buy_symbols_momentum.txt"
          LOTS_OUT:      "backtests/momentum_lots.csv"
          WEEK_FRIDAY:   ${{ steps.when.outputs.friday }}
          STRATEGY:      "momentum"
        run: python tools/place_weekly_buys.py

      # ======================
      # BREAKOUT
      # ======================
      - name: Prepare BREAKOUT buy list (Top 6 by market cap) — skip only open buys
        id: brklist
        if: ${{ env.ENABLE_BREAKOUT == 'true' && steps.gate.outputs.go == '1' && steps.buygate.outputs.do == '1' && steps.brk.outputs.found == '1' }}
        env:
          ALPACA_KEY:    ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENV:    live
        shell: python
        run: |
          import os, requests
          from pathlib import Path

          syms=[s.strip().upper() for s in Path("backtests/breakout_symbols.txt").read_text(encoding="utf-8").splitlines() if s.strip()]
          syms = syms[:6]

          base = "https://paper-api.alpaca.markets" if os.getenv("ALPACA_ENV","paper").startswith("paper") else "https://api.alpaca.markets"
          H = {"APCA-API-KEY-ID": os.environ["ALPACA_KEY"], "APCA-API-SECRET-KEY": os.environ["ALPACA_SECRET"]}

          buying=set()
          r=requests.get(f"{base}/v2/orders", params={"status":"open","limit":500}, headers=H, timeout=20)
          if r.status_code==200:
              for od in (r.json() or []):
                  if od.get("side")=="buy" and od.get("symbol"):
                      buying.add(od["symbol"].upper())

          filtered=[s for s in syms if s not in buying]
          Path("backtests/buy_symbols_breakout.txt").write_text("\n".join(filtered)+("\n" if filtered else ""), encoding="utf-8")

          any_buy="1" if filtered else "0"
          print("Breakout top6:", syms)
          print("Filtered breakout:", filtered)
          open(os.environ["GITHUB_OUTPUT"],"a").write(f"any={any_buy}\n")

      - name: Execute BREAKOUT buys (notional per name) + write lots
        id: brkbuy
        if: ${{ env.ENABLE_BREAKOUT == 'true' && steps.gate.outputs.go == '1' && steps.buygate.outputs.do == '1' && steps.brklist.outputs.any == '1' }}
        env:
          ALPACA_KEY:    ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENV:    live
          NOTIONAL_PER:  ${{ env.BREAKOUT_NOTIONAL }}
          BUY_LIST_PATH: "backtests/buy_symbols_breakout.txt"
          LOTS_OUT:      "backtests/breakout_lots.csv"
          WEEK_FRIDAY:   ${{ steps.when.outputs.friday }}
          STRATEGY:      "breakout"
        run: python tools/place_weekly_buys.py

      # --- Ensure lot/report files exist (even if no buys) ---
      - name: Ensure lot/report files exist (even if no buys)
        if: always()
        shell: bash
        run: |
          set -e
          mkdir -p backtests
          test -f backtests/momentum_lots.csv || echo "symbol,qty" > backtests/momentum_lots.csv
          test -f backtests/breakout_lots.csv || echo "symbol,qty" > backtests/breakout_lots.csv
          test -f backtests/buy_exec_report.csv || echo "symbol,status,qty,price_used,order_id,msg" > backtests/buy_exec_report.csv
          ls -la backtests

      # --- Upload lot files for Friday flatten (LATEST) ---
      - name: Upload lots (latest)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: iw-lots-latest
          path: |
            backtests/momentum_lots.csv
            backtests/breakout_lots.csv
            backtests/buy_exec_report.csv
          if-no-files-found: warn

      # Mark as opened only if at least one strategy actually had buys
      - name: Mark opened
        if: ${{ steps.gate.outputs.go == '1' && steps.buygate.outputs.do == '1' && (steps.momlist.outputs.any == '1' || steps.brklist.outputs.any == '1') }}
        run: mkdir -p .open-flag && date > .open-flag/ok
