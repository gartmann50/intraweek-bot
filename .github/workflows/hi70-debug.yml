name: hi70-debug (current week)

on:
  workflow_dispatch:
    inputs:
      top:
        description: "How many tickers to show"
        required: false
        default: "10"
      cap_min:
        description: "Min market cap USD"
        required: false
        default: "1000000000"
      min_price:
        description: "Min last close"
        required: false
        default: "5"
      min_dollar_vol:
        description: "Min dollar volume (close*volume of last bar)"
        required: false
        default: "10000000"
      send_email:
        description: "Email the list if non-empty (true/false)"
        required: false
        default: "false"

permissions:
  contents: read

jobs:
  debug:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas requests pyyaml

      # Overwrite the scanner with a clean, known-good copy and compile-check it.
      - name: Overwrite tools/scan_70d_highs.py + compile
        shell: bash
        run: |
          mkdir -p tools
          cat > tools/scan_70d_highs.py <<'PY'
#!/usr/bin/env python3
from __future__ import annotations
import argparse, csv, os, sys, time, requests
from dataclasses import dataclass
from datetime import date, datetime, timedelta
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse, parse_qs
try:
    from zoneinfo import ZoneInfo
except Exception:
    from backports.zoneinfo import ZoneInfo  # type: ignore

NY = ZoneInfo("America/New_York")
POLY_TICKERS = "https://api.polygon.io/v3/reference/tickers"
POLY_AGGS    = "https://api.polygon.io/v2/aggs/ticker/{sym}/range/1/day/{start}/{end}"

def ny_today() -> date:
    return datetime.now(NY).date()

def last_friday_ny() -> date:
    d = ny_today()
    while d.weekday() != 4:  # Friday=4
        d -= timedelta(days=1)
    return d

def ymd(d: date) -> str:
    return d.isoformat()

def backoff_sleep(k: int) -> None:
    time.sleep(min(0.5 * (2**k), 6.0))

def http_get_json(url: str, params: Dict[str,str], max_tries: int = 6) -> Dict:
    last = None
    for k in range(max_tries):
        try:
            r = requests.get(url, params=params, timeout=30)
            if r.status_code == 429:
                backoff_sleep(k); continue
            r.raise_for_status()
            return r.json() or {}
        except requests.HTTPError as e:
            last = e
            if r.status_code >= 500:
                backoff_sleep(k); continue
            break
        except Exception as e:
            last = e
            backoff_sleep(k)
    raise RuntimeError(f"GET failed {url} ({last})")

def list_common_stocks(api_key: str, pages: int, on_date: Optional[date]) -> List[Dict]:
    params = {"market":"stocks","active":"true","type":"CS","limit":"1000","apiKey":api_key}
    if on_date: params["date"] = ymd(on_date)
    results: List[Dict] = []; cursor: Optional[str] = None; page_n = 0
    while True:
        p = dict(params)
        if cursor: p["cursor"] = cursor
        j = http_get_json(POLY_TICKERS, p)
        results.extend(j.get("results", []) or [])
        page_n += 1
        nxt = j.get("next_url") or ""
        cursor = parse_qs(urlparse(nxt).query).get("cursor", [None])[0] if nxt else None
        if not cursor or page_n >= pages:
            break
    return results

def fetch_daily_bars(api_key: str, symbol: str, start: date, end: date) -> List[Dict]:
    url = POLY_AGGS.format(sym=symbol, start=ymd(start), end=ymd(end))
    p = {"adjusted":"true","sort":"asc","limit":"50000","apiKey":api_key}
    j = http_get_json(url, p)
    return j.get("results", []) or []

@dataclass
class Candidate:
    symbol: str; name: str; market_cap: float
    prior70h: float; week_high: float; week_close: float
    gap_high_pct: float; gap_close_pct: float
    first_break_day: str; bars: int

def detect_week_breakout(bars: List[Dict], mon: date, week_end: date) -> Tuple[float,float,float,float,str]:
    if not bars: return (0.0,0.0,0.0,0.0,"")
    def as_date(ms:int)->date: return datetime.utcfromtimestamp(ms/1000).date()
    before, during = [], []
    for b in bars:
        d = as_date(int(b.get("t",0)))
        if d < mon: before.append(b)
