name: Weekly Picks

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Choose: status, build, email_smoke, build_and_email"
        required: true
        default: build_and_email
        type: choice
        options:
          - status
          - build
          - email_smoke
          - build_and_email
      until:
        description: "Override Friday (YYYY-MM-DD). Leave empty to auto-pick last Friday (Oslo)"
        required: false
        type: string
      topk:
        description: "How many names to show/email"
        required: false
        default: "6"
        type: string

jobs:
  main:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas numpy pyyaml

      - name: Compute last Friday (Europe/Oslo)
        id: when
        run: |
          python - <<'PY'
          from datetime import datetime, timedelta
          import zoneinfo, os, json
          tz = zoneinfo.ZoneInfo("Europe/Oslo")
          now = datetime.now(tz)
          # If user supplied --until, use that, else compute last Friday
          override = "${{ inputs.until }}".strip()
          if override:
            fri = override
          else:
            d = now.date()
            # step back to previous Friday (including today if Fri)
            while d.weekday() != 4:
              d -= timedelta(days=1)
            fri = d.isoformat()
          # next Monday after that Friday
          f = datetime.fromisoformat(fri).date()
          next_mon = f + timedelta(days=3)
          print("FRI=", fri)
          print("MON=", next_mon.isoformat())
          with open("runner_dates.json","w") as fjson:
            json.dump({"friday": fri, "next_monday": next_mon.isoformat()}, fjson)
          print(f"::set-output name=friday::{fri}")
          print(f"::set-output name=monday::{next_mon.isoformat()}")
          PY

      # Always show a quick repo tree to help debugging
      - name: Quick tree
        run: |
          echo "Top-level files:"
          ls -la
          echo ""
          echo "Data dir (stock_data_400):"
          ls -la stock_data_400 | head -n 40 || true

      # --- STATUS (sanity) ---
      - name: Status (sanity only)
        if: ${{ inputs.mode == 'status' }}
        run: |
          echo "Sanity OK. CSV count:"
          ls stock_data_400/*.csv | wc -l

      - name: Unpack EOD dataset if zip present
        if: hashFiles('stock_data_400.zip') != ''
        shell: python
        run: |
          import os, zipfile, shutil, pathlib

          z = zipfile.ZipFile('stock_data_400.zip')
          os.makedirs('stock_data_400', exist_ok=True)
          z.extractall('stock_data_400')

          moved = 0
          for p in pathlib.Path('stock_data_400').rglob('*.csv'):
             dst = pathlib.Path('stock_data_400') / p.name
             if p.resolve() != dst.resolve():
                shutil.move(str(p), str(dst))
                moved += 1

          csvs = [p for p in os.listdir('stock_data_400') if p.lower().endswith('.csv')]
          print("Unzipped CSVs:", len(csvs), "(moved:", moved, ")")

      - name: Sanity — count & peek one CSV
        shell: python
        run: |
          import glob, pandas as pd
          files = sorted(glob.glob('stock_data_400/*.csv'))
          print("Found", len(files), "CSV files in stock_data_400/")
          if not files:
             raise SystemExit("No CSVs found after unzip")

          print("Sample:", files[0])
          df = pd.read_csv(files[0]).head()
          print(df.to_string(index=False))

      # --- BUILD PICKLIST ---
      - name: Build weekly picklist (RSI≥68, rank=rsi, ext20≤0.15, Top-40/wk)
        run: |
          python build_picklist_parametric.py \
            --data-dir stock_data_400 \
            --rsi-min 68 \
            --max-ext20 0.15 \
            --top-per-week 40 \
            --until "${UNTIL}" \
            --out backtests/picklist_highrsi_trend.csv

      - name: Check picklist (exists + head)
        run: |
          ls -lh backtests || true
          python -c "import pandas as pd, pathlib, sys; p=pathlib.Path('backtests/picklist_highrsi_trend.csv'); print('exists:', p.exists(), 'size:', p.stat().st_size if p.exists() else 0); (not p.exists()) and sys.exit(1); df=pd.read_csv(p); print('rows:', len(df)); print(df.head(10).to_string(index=False)); sys.exit(0 if len(df) else 1)"

      - name: Preview Top-6 in logs + save file
        if: ${{ inputs.mode == 'build' || inputs.mode == 'build_and_email' }}
        run: |
          python preview_top6.py \
            --picklist backtests/picklist_highrsi_trend.csv \
            --topk "${{ inputs.topk }}" \
            --until "${{ steps.when.outputs.friday }}" | tee backtests/top6_preview.txt

          echo "== Tail of picklist =="
          tail -n 20 backtests/picklist_highrsi_trend.csv || true

      - name: Upload artifacts (picklist + preview)
        if: ${{ inputs.mode == 'build' || inputs.mode == 'build_and_email' }}
        uses: actions/upload-artifact@v4
        with:
          name: weekly-picks-${{ steps.when.outputs.friday }}
          path: |
            backtests/picklist_highrsi_trend.csv
            backtests/top6_preview.txt
            runner_dates.json

      # --- EMAIL (smoke or real) ---
      - name: Create email config from secrets
        if: ${{ inputs.mode == 'email_smoke' || inputs.mode == 'build_and_email' }}
        env:
          GMAIL_USER: ${{ secrets.GMAIL_USER }}
          GMAIL_APP_PASS: ${{ secrets.GMAIL_APP_PASS }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
        run: |
          python - <<'PY'
          import os, json, pathlib, sys, yaml
          out = {
            "smtp": {
              "host": "smtp.gmail.com",
              "port": 587,
              "user": os.environ.get("GMAIL_USER",""),
              "pass": os.environ.get("GMAIL_APP_PASS",""),
            },
            "from": os.environ.get("MAIL_FROM",""),
            # allow comma or semicolon separated
            "to": [e.strip() for e in os.environ.get("MAIL_TO","").replace(";",",").split(",") if e.strip()]
          }
          pathlib.Path("config_notify_ci.yaml").write_text(yaml.safe_dump(out, sort_keys=False), encoding="utf-8")
          print("Wrote config_notify_ci.yaml with", len(out["to"]), "recipient(s).")
          PY

      - name: Email smoke (short test)
        if: ${{ inputs.mode == 'email_smoke' }}
        run: |
          python notify_picks.py --config config_notify_ci.yaml --smoke

      - name: Write config_notify.yaml (from secrets)
        run: |
          cat > config_notify.yaml <<'YAML'
          smtp_user: ${{ secrets.SMTP_USER }}
          smtp_pass: ${{ secrets.SMTP_PASS }}
          smtp_to:   ${{ secrets.SMTP_TO }}
          smtp_from: ${{ secrets.SMTP_FROM }}
          host: smtp.gmail.com
          port: 587
          use_tls: true
          YAML

      - name: Show config_notify.yaml (redacted)
        run: |
          python -c "import yaml, pathlib; cfg=yaml.safe_load(pathlib.Path('config_notify.yaml').read_text()) or {}; print({k:('***' if any(s in k for s in ('pass','user','key','token')) else v) for k,v in cfg.items()})"


      - name: Email weekly picks (poem + full names, BCC recipients)
        env:
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_TO:   ${{ secrets.SMTP_TO }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
        run: |
          python notify_picks.py \
          --config config_notify.yaml \
          --picklist backtests/picklist_highrsi_trend.csv \
          --topk "${{ inputs.topk || 6 }}" \
          --week "${{ steps.when.outputs.friday }}"
