name: Weekly Picks (manual)

on:
  workflow_dispatch:
    inputs:
      mode:
        type: choice
        description: What to run
        options: [status, build, email_smoke]
        required: true
        default: build
      until:
        description: Override "until" date (YYYY-MM-DD). Blank = today (Oslo)
        required: false
        default: ""
      topk:
        description: How many symbols to show/send
        required: false
        default: "6"

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      TZ: Europe/Oslo

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas numpy pyyaml pytz tzdata requests

      - name: Compute UNTIL date and shell flags
        id: compute
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${{ github.event.inputs.until || '' }}" ]]; then
            UNTIL=$(TZ=Europe/Oslo date +%F)
          else
            UNTIL="${{ github.event.inputs.until }}"
          fi
          echo "UNTIL=$UNTIL" >> $GITHUB_ENV
          echo "TOPK=${{ github.event.inputs.topk || '6' }}" >> $GITHUB_ENV

      - name: Ensure folders
        run: |
          mkdir -p backtests stock_data_400 notifications

      # ----- EMAIL CONFIG FROM SECRETS (Gmail) -----
      - name: Write config_notify.yaml (Gmail, from secrets)
        env:
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          SMTP_TO:   ${{ secrets.SMTP_TO }}
        shell: bash
        run: |
          set -euo pipefail
          : "${SMTP_USER:?Missing secret SMTP_USER}"
          : "${SMTP_PASS:?Missing secret SMTP_PASS}"
          : "${SMTP_TO:?Missing secret SMTP_TO}"
          {
            echo "smtp:"
            echo "  host: smtp.gmail.com"
            echo "  port: 587"
            echo "  user: \"${SMTP_USER}\""
            echo "  pass: \"${SMTP_PASS}\""
            echo "  from: \"${SMTP_FROM:-$SMTP_USER}\""
            echo "  to:"
            IFS=',' read -ra ADDR <<< "${SMTP_TO}"
            for a in "${ADDR[@]}"; do
              a_trimmed="$(echo "$a" | xargs)"
              echo "    - \"${a_trimmed}\""
            done
            echo "poems: []"
          } > config_notify.yaml

      - name: Show config_notify.yaml (redacted)
        shell: bash
        run: |
          sed -E 's/(pass: ).*/\1********/' config_notify.yaml

      - name: STATUS — show inputs and time
        if: ${{ github.event.inputs.mode == 'status' }}
        run: |
          echo "UNTIL=${UNTIL}"; echo "TOPK=${TOPK}"; date

      # ----- BUILD PICKLIST -----
      - name: Build weekly picklist (RSI>=68, rank=rsi, max_ext20=0.15, Top-40/wk)
        if: ${{ github.event.inputs.mode == 'build' }}
        shell: bash
        run: |
          python build_picklist_parametric.py \
            --data-dir stock_data_400 \
            --out backtests/picklist_highrsi_trend.csv \
            --rsi-min 68 \
            --max-ext20 0.15 \
            --top-per-week 40 \
            --until "${UNTIL}"

      # ----- INLINE PREVIEW (no external script needed) -----
      - name: Preview Top-6 (inline)
        if: ${{ github.event.inputs.mode == 'build' }}
        continue-on-error: true
        shell: bash
        run: |
          python - <<'PY'
          import os, pandas as pd, numpy as np, sys
          path = 'backtests/picklist_highrsi_trend.csv'
          topk = int(os.environ.get('TOPK','6'))
          until = os.environ.get('UNTIL','')
          if not os.path.exists(path):
              print(f"[Preview] Picklist not found: {path}")
              sys.exit(0)

          df = pd.read_csv(path)
          if df.empty:
              print(f"[Preview] Picklist is empty: {path}")
              sys.exit(0)

          # normalize columns
          df.columns = [c.strip().lower() for c in df.columns]
          wk_candidates = ['week_start','week_start_date','weekstart','week']
          wkcol = next((c for c in wk_candidates if c in df.columns), None)
          if not wkcol:
              print(f"[Preview] No week column found (tried {wk_candidates}). Columns: {list(df.columns)}")
              sys.exit(0)

          # try parsing; if nothing parses, fall back to string comparison
          s = pd.to_datetime(df[wkcol], errors='coerce')
          if s.notna().any():
              df['_wk'] = s
              try:
                  until_dt = pd.to_datetime(until) if until else df['_wk'].max()
              except Exception:
                  until_dt = df['_wk'].max()
              latest = df.loc[df['_wk'] <= until_dt, '_wk'].max()
              sub = df[df['_wk'] == latest].copy() if pd.notna(latest) else pd.DataFrame()
          else:
              # fallback: compare by canonical YYYY-MM-DD string
              ss = df[wkcol].astype(str).str.slice(0,10)
              latest_s = ss.max()
              df['_wkstr'] = ss
              sub = df[df['_wkstr'] == latest_s].copy()

          if sub.empty:
              print(f"[Preview] No rows matched by week <= {until} (or latest week).")
              # Show available weeks to help debugging
              sample = df[wkcol].astype(str).str.slice(0,10).value_counts().head(10)
              print("[Preview] Available week labels (top 10):")
              print(sample.to_string())
              sys.exit(0)

          # rank/score ordering
          order_cols = [c for c in ('rank','score') if c in sub.columns]
          if 'rank' in sub.columns:
              sub = sub.sort_values('rank', ascending=True)
          elif 'score' in sub.columns:
              sub = sub.sort_values('score', ascending=False)

          cols = ['symbol'] + [c for c in ('rank','score') if c in sub.columns]
          top = sub.head(topk)
          # derive display of the week we picked
          chosen_week = None
          if '_wk' in top.columns and top['_wk'].notna().any():
              chosen_week = top['_wk'].iloc[0]
          elif '_wkstr' in top.columns:
              chosen_week = top['_wkstr'].iloc[0]
          print(f"Week preview: {str(chosen_week)[:10]} | Top-{topk}")
          print(top[cols].to_string(index=False))
          PY


      - name: EMAIL_SMOKE — send test email (Bcc to SMTP_TO)
        if: ${{ github.event.inputs.mode == 'email_smoke' }}
        env:
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          SMTP_TO:   ${{ secrets.SMTP_TO }}
        shell: bash
        run: |
          python - <<'PY'
          import os, smtplib, ssl
          from email.message import EmailMessage
          to=os.environ.get("SMTP_TO","")
          to=[x.strip() for x in to.split(",") if x.strip()]
          msg=EmailMessage()
          msg["Subject"]="Smoke test from GitHub Actions"
          msg["From"]=os.environ.get("SMTP_FROM") or os.environ["SMTP_USER"]
          msg["To"]=os.environ["SMTP_USER"]
          if to: msg["Bcc"]=",".join(to)
          msg.set_content("Smoke test OK.")
          with smtplib.SMTP("smtp.gmail.com",587) as s:
              s.starttls(context=ssl.create_default_context())
              s.login(os.environ["SMTP_USER"],os.environ["SMTP_PASS"])
              s.send_message(msg)
          PY

      - name: Email weekly picks
  # only send on a build/open/close run; keep if-condition you already use
        if: ${{ github.event.inputs.mode == 'build' || startsWith(github.event.inputs.mode, 'open_') || startsWith(github.event.inputs.mode, 'close') }}
        env:
    # feed secrets to the script via environment (no need for a config file)
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_TO:   ${{ secrets.SMTP_TO }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          TOPK:      ${{ github.event.inputs.topk || '6' }}
        run: |
          python notify_picks.py \
            --picklist backtests/picklist_highrsi_trend.csv \
            --topk "${TOPK}"
